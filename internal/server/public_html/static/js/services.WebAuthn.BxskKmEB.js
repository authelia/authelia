import{b as S}from"./browserSupportsWebAuthn.Bhlk1eaM.js";import{a4 as b,bc as O,bd as F,be as N,bf as I,bg as D,b2 as U,bh as _}from"./index.BAKKlMLi.js";var l=(e=>(e[e.Success=1]="Success",e[e.Failure=2]="Failure",e[e.FailureExcluded=3]="FailureExcluded",e[e.FailureUserConsent=4]="FailureUserConsent",e[e.FailureUserVerificationOrResidentKey=5]="FailureUserVerificationOrResidentKey",e[e.FailureSyntax=6]="FailureSyntax",e[e.FailureSupport=7]="FailureSupport",e[e.FailureUnknown=8]="FailureUnknown",e[e.FailureWebAuthnNotSupported=9]="FailureWebAuthnNotSupported",e[e.FailureToken=10]="FailureToken",e))(l||{}),h=(e=>(e[e.Success=1]="Success",e[e.Failure=2]="Failure",e[e.FailureUserConsent=3]="FailureUserConsent",e[e.FailureU2FFacetID=4]="FailureU2FFacetID",e[e.FailureSyntax=5]="FailureSyntax",e[e.FailureUnknown=6]="FailureUnknown",e[e.FailureUnknownSecurity=7]="FailureUnknownSecurity",e[e.FailureWebAuthnNotSupported=8]="FailureWebAuthnNotSupported",e[e.FailureChallenge=9]="FailureChallenge",e[e.FailureUnrecognized=10]="FailureUnrecognized",e))(h||{});function G(e){switch(e){case 1:return"";case 3:return"You cancelled the assertion request";case 4:return"The server responded with an invalid Facet ID for the URL";case 5:return"The assertion challenge was rejected as malformed or incompatible by your browser";case 8:return"Your browser does not support the WebAuthn protocol";case 10:return"This device is not registered";case 7:return"An unknown security error occurred";case 6:return"An unknown error occurred";default:return"An unexpected error occurred"}}function j(e){switch(e){case 10:return"You must open the link from the same device and browser that initiated the registration process";case 7:return"Your browser does not appear to support the configuration";case 6:return"The attestation challenge was rejected as malformed or incompatible by your browser";case 9:return"Your browser does not support the WebAuthn protocol";case 4:return"You cancelled the attestation request";case 5:return"Your device does not support user verification or resident keys but this was required";case 3:return"You have registered this device already";case 8:return"An unknown error occurred"}return""}function z(e){switch(e.toLowerCase()){case"cross-platform":return"Cross-Platform";case"platform":return"Platform";default:return"Unknown"}}function Q(e){switch(e.toLowerCase()){case"internal":return"Internal";case"ble":return"Bluetooth";case"nfc":case"usb":return e.toUpperCase();default:return e}}var K=(e=>(e[e.WaitTouch=1]="WaitTouch",e[e.InProgress=2]="InProgress",e[e.Failure=3]="Failure",e))(K||{});function p(e){const t=new Uint8Array(e);let r="";for(const a of t)r+=String.fromCharCode(a);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function E(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,n=t.padEnd(t.length+r,"="),a=atob(n),i=new ArrayBuffer(a.length),c=new Uint8Array(i);for(let s=0;s<a.length;s++)c[s]=a.charCodeAt(s);return i}function C(e){const{id:t}=e;return{...e,id:E(t),transports:e.transports}}function T(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class o extends Error{constructor({message:t,code:r,cause:n,name:a}){super(t,{cause:n}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=a??n.name,this.code=r}}function W({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new o({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(r.authenticatorSelection?.requireResidentKey===!0)return new o({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&r.authenticatorSelection?.userVerification==="required")return new o({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(r.authenticatorSelection?.userVerification==="required")return new o({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new o({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new o({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return r.pubKeyCredParams.filter(a=>a.type==="public-key").length===0?new o({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new o({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const n=globalThis.location.hostname;if(T(n)){if(r.rp.id!==n)return new o({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new o({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new o({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new o({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class x{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const r=new Error("Cancelling existing WebAuthn API call for new one");r.name="AbortError",this.controller.abort(r)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const P=new x,k=["cross-platform","platform"];function v(e){if(e&&!(k.indexOf(e)<0))return e}async function L(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:r=!1}=e;if(!S())throw new Error("WebAuthn is not supported in this browser");const n={...t,challenge:E(t.challenge),user:{...t.user,id:E(t.user.id)},excludeCredentials:t.excludeCredentials?.map(C)},a={};r&&(a.mediation="conditional"),a.publicKey=n,a.signal=P.createNewAbortSignal();let i;try{i=await navigator.credentials.create(a)}catch(d){throw W({error:d,options:a})}if(!i)throw new Error("Registration was not completed");const{id:c,rawId:s,response:u,type:y}=i;let f;typeof u.getTransports=="function"&&(f=u.getTransports());let m;if(typeof u.getPublicKeyAlgorithm=="function")try{m=u.getPublicKeyAlgorithm()}catch(d){A("getPublicKeyAlgorithm()",d)}let g;if(typeof u.getPublicKey=="function")try{const d=u.getPublicKey();d!==null&&(g=p(d))}catch(d){A("getPublicKey()",d)}let w;if(typeof u.getAuthenticatorData=="function")try{w=p(u.getAuthenticatorData())}catch(d){A("getAuthenticatorData()",d)}return{id:c,rawId:p(s),response:{attestationObject:p(u.attestationObject),clientDataJSON:p(u.clientDataJSON),transports:f,publicKeyAlgorithm:m,publicKey:g,authenticatorData:w},type:y,clientExtensionResults:i.getClientExtensionResults(),authenticatorAttachment:v(i.authenticatorAttachment)}}function A(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function M(){if(!S())return R.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?R.stubThis(new Promise(t=>t(!1))):R.stubThis(e.isConditionalMediationAvailable())}const R={stubThis:e=>e};function Y({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new o({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new o({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const n=globalThis.location.hostname;if(T(n)){if(r.rpId!==n)return new o({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new o({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new o({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function V(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:r=!1,verifyBrowserAutofillInput:n=!0}=e;if(!S())throw new Error("WebAuthn is not supported in this browser");let a;t.allowCredentials?.length!==0&&(a=t.allowCredentials?.map(C));const i={...t,challenge:E(t.challenge),allowCredentials:a},c={};if(r){if(!await M())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&n)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');c.mediation="conditional",i.allowCredentials=[]}c.publicKey=i,c.signal=P.createNewAbortSignal();let s;try{s=await navigator.credentials.get(c)}catch(w){throw Y({error:w,options:c})}if(!s)throw new Error("Authentication was not completed");const{id:u,rawId:y,response:f,type:m}=s;let g;return f.userHandle&&(g=p(f.userHandle)),{id:u,rawId:p(y),response:{authenticatorData:p(f.authenticatorData),clientDataJSON:p(f.clientDataJSON),signature:p(f.signature),userHandle:g},type:m,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:v(s.authenticatorAttachment)}}function $(e){switch(e.name){case"UnknownError":return l.FailureSyntax;case"NotSupportedError":return l.FailureSupport;case"InvalidStateError":return l.FailureExcluded;case"AbortError":case"NotAllowedError":return l.FailureUserConsent;case"ConstraintError":return l.FailureUserVerificationOrResidentKey;default:return console.error(`Unhandled DOMException occurred during WebAuthn attestation: ${e}`),l.FailureUnknown}}function B(e,t){switch(e.name){case"UnknownError":return h.FailureSyntax;case"InvalidStateError":return h.FailureUnrecognized;case"AbortError":case"NotAllowedError":return h.FailureUserConsent;case"SecurityError":return t.extensions?.appid!==void 0?h.FailureU2FFacetID:h.FailureUnknownSecurity;default:return console.error(`Unhandled DOMException occurred during WebAuthn assertion: ${e}`),h.FailureUnknown}}async function X(){let e;return e=await b.get(F),e.data.status!=="OK"||e.data.data==null?{status:e.status}:{options:e.data.data.publicKey,status:e.status}}async function Z(e){const t={result:h.Success};try{t.response=await V({optionsJSON:e})}catch(r){const n=r;if(n!==void 0)return t.result=B(n,e),console.error(n),t;console.error(`Unhandled exception occurred during WebAuthn authentication: ${r}`)}return t.response==null?t.result=h.Failure:t.result=h.Success,t}async function ee(e,t,r,n,a,i){return b.post(F,{response:e,targetURL:t,flowID:r,flow:n,subflow:a,userCode:i})}async function te(){let e;return e=await b.get(O),e.data.status!=="OK"||e.data.data==null?{status:e.status}:{options:e.data.data.publicKey,status:e.status}}async function re(e,t,r,n,a,i,c){const s={response:e,keepMeLoggedIn:t,targetURL:r,requestMethod:n,flowID:a,flow:i,subflow:c};return b.post(O,s)}async function ne(e){const t=await b.put(I,{description:e},{validateStatus:D});return t.data.status!=="OK"||t.data.data==null?{status:t.status}:{options:t.data.data.publicKey,status:t.status}}async function ae(e){const t={result:l.Failure};try{t.response=await L({optionsJSON:e})}catch(r){const n=r;if(n!==void 0)return t.result=$(n),console.error(n),t;console.error(`Unhandled exception occurred during WebAuthn attestation: ${r}`)}return t.response!=null&&(t.result=l.Success),t}async function H(e){return b.post(I,e)}async function oe(e){let t={status:l.Failure,message:"Device registration failed."};try{const r=await H(e);if(r.data.status==="OK"&&(r.status===200||r.status===201))return{status:l.Success,message:""}}catch(r){r instanceof N&&r.response!==void 0&&(t.message=r.response.data.message)}return t}async function ie(e){return b({method:"DELETE",url:`${_}/${e}`,validateStatus:U})}async function se(e,t){return b({method:"PUT",url:`${_}/${e}`,data:{description:t},validateStatus:U})}export{l as A,K as W,Q as a,j as b,te as c,ie as d,Z as e,oe as f,ne as g,h,G as i,X as j,ee as k,re as p,ae as s,z as t,se as u};
